/* getint: get next integer from input into *pn  

  On a PC running Windows, EOF via a keyboard can be generated by CTRL-Z

  Changed main to int and added a return value to avoid compiler warnings

    compiled by:
      bcc32c ch5-IntArray.c [ENTER]    

 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define SIZE 10   /* size of integer array */

#define MAXOP 100    /* max size of operand or operator */
#define NUMBER '0'   /* signal that a number was found */
#define MAXVAL 100   /* maximum depth of val stack */
#define BUFSIZE 100  

int sp = 0;         /* next free stack position */
double val[MAXVAL]; /* value stack */
char buf[BUFSIZE];  /* buffer for ungetch */
int bufp = 0;       /* next free position in buf */

int getch(void);
void ungetch(int c);
int getint(int *pn);


int main()
{ 
  int n, array[SIZE];

  for ( n = 0; n < SIZE && getint(&array[n]) != EOF; n++)
    ;

  for ( n = 0; n < SIZE; n++) 
    printf(" %d",array[n]);

  return (0);
}


int getint(int *pn)
{
  int c, sign;

  while ( isspace(c = getch()) )  /* skip white space */
    ;

  if ( !isdigit(c) && c != EOF && c != '+' && c != '-' )
  {
    ungetch(c);   /* it's not a number */
    return(0);
  }

  sign = (c == '-') ? -1 : 1;

  if ( c== '+' || c == '-' )
    c = getch();

  for ( *pn = 0; isdigit(c); c = getch() )
    *pn = 10 * *pn + ( c - '0' );

  *pn *= sign;

  if ( c != EOF )
    ungetch(c);

  return(c);
}


/* getch: get a (possibly pushed back) character */
int getch(void)
{
  return(bufp > 0 ? buf[--bufp] : getchar());
}


/* ungetch: push character back on input */
void ungetch(int c)
{  
  if ( bufp >= BUFSIZE )
    printf("ungetch: too many characters\n");
  else  
    buf[bufp++] = c;
}



