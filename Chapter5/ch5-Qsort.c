/* qsort: sort array of lines into increasing order

   On a PC running Windows, EOF via a keyboard can be generated by CTRL-Z

  Changed main to int and added a return value to avoid compiler warnings

    compiled by:
      bcc32c ch5-Qsort.c [ENTER]    

 */

#include <stdio.h>
#include <string.h>

#define MAXLINES 5000              /* max #lines to be sorted */
#define MAXLEN 1000                /* max length of any input line */
#define ALLOCSIZE MAXLINES*MAXLEN  /* size of available space */

char allocbuf[ALLOCSIZE];  /* storage of alloc */
char *allocp = allocbuf;   /* next free position */

char *lineptr[MAXLINES];  /* pointers to text lines */


/* getline: get line into s, return length */
int getline(char s[], int lim)
{
  int c, i;

  i = 0;
  while ( --lim > 0 && (c=getchar()) != EOF && c != '\n' )
    s[i++] = c;
  if ( c == '\n')
    s[i++] = c;
  s[i] = '\0';
  return(i);
}


/* return pointer to n characters */
char *alloc(int n)
{
   if ( allocbuf + ALLOCSIZE - allocp >= n )
   {
      /* it fits */
      allocp += n;
      return(allocp - n); /* old p */
   }
   else  
     return(0); /* not enough room */
}


/* swap: interchange v[i] and v[j] */
void swap(char *v[], int i, int j)
{
  char *temp;

  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}


/* qsort: sort v[left]...v[right] into increasing order */
void qsort(char *v[], int left, int right)
{
  int i, last;

  /* changed original code which had this check if parameters indicated 2 or less elements
     if ( left >= right )
       return;
  */
  if ( left < right )
  {
    swap(v, left, (left+right)/2);  /* move partition element */
    last = left;                    /* to v[0] */
    for ( i = left+1; i <= right; i++ ) /* partition */
      if ( strcmp(v[i], v[left]) < 0 )
        swap(v, ++last, i);
    swap(v, left, last); /* restore partition elem */ 
    qsort(v, left, last-1);
    qsort(v, last+1, right);
  }
}


/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines)
{
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ( (len = getline(line, MAXLEN)) > 0 )
      if ( nlines >= maxlines || (p = alloc(len)) == NULL )
        return(-1);
    else
    {
      line[len-1] = '\0'; /* delete newline */
      strcpy(p, line);
      lineptr[nlines++] = p;
    }

    return(nlines);
}


/* writelines: write output lines */
void writelines(char *lineptr[], int nlines)
{
   int i;

   for ( i = 0; i < nlines; i++ )
     printf("%d: %s\n", i, lineptr[i]);

}


/* sort input lines */
int main()
{ 
  int nlines;   /* number of input lines read */

  if ( ( nlines = readlines(lineptr, MAXLINES)) >= 0 )
  {
    qsort(lineptr, 0, nlines-1);
    writelines(lineptr, nlines);
    return(0);
  }
  else
  {
    printf("error: input too big to sort\n");
    return(1);
  }

}